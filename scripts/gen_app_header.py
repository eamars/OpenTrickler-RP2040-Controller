import argparse
import logging
import subprocess
import sys
import re
import os


GIT_VERSION_COMMAND = ["git", "describe", "--tags", "--long", "--dirty", "--always"]

GIT_VERSION_PATTERN_REGEX = r'v(?P<major>\d+)\.(?P<minor>\d+)-(?P<patch>\d+)-g(?P<short_hash>[a-f0-9]+)(?P<dirty>-dirty)?'


C_SOURCE_TEMPLATE = """// ---------------------------------------------------------------------- //
// This file is auto-generated by gen_application_header.py; do not edit! //
// ---------------------------------------------------------------------- //

#include "app_header.h"

#ifdef __cplusplus
extern "C"
{{
#endif

__attribute__ ((section (".app_header")))
__attribute__ ((used))
const app_header_t __app_header = {{
    .app_header_rev = {app_header_rev},
    .flash_partition_idx = {flash_partition_idx},
    .vcs_hash = "{vcs_hash}",
    .build_type = "{build_type}",
    .firmware_version = "{firmware_version}",
}};


const app_header_t * get_app_header(void)
{{
    return &__app_header;
}}


#ifdef __cplusplus
}}
#endif
"""


def main(output_path, build_type, flash_partition_idx):
    output = subprocess.check_output(GIT_VERSION_COMMAND, text=True)

    logging.debug(f'Raw output: {output}')
    match = re.match(GIT_VERSION_PATTERN_REGEX, output)

    version_string = "unknown"
    hash_string = ""

    if match:
        groupdict = match.groupdict()

        major = groupdict['major']
        minor = groupdict['minor']
        patch = groupdict['patch']
        short_hash = groupdict['short_hash']
        dirty = groupdict['dirty']

        dirty_string = ""
        if dirty:  # In case the dirty is None
            dirty_string = dirty

        version_string = f"{major}.{minor}.{patch}{dirty_string}"
        hash_string = short_hash

    c_source_string = C_SOURCE_TEMPLATE.format(
        app_header_rev=1,
        flash_partition_idx=flash_partition_idx,
        vcs_hash=hash_string,
        build_type=build_type,
        firmware_version=version_string,
    )

    c_source_filepath = os.path.join(output_path, f"app_header_{flash_partition_idx}.c")
    with open(c_source_filepath, "w") as fp:
        logging.debug(f"Write to {c_source_filepath}")
        fp.write(c_source_string)


if __name__ == "__main__":
    parser = argparse.ArgumentParser()

    parser.add_argument('-o', '--output_filepath', help="The output filepath that the C source will be written to", required=True)
    parser.add_argument('--build-type', help="CMake build type", required=True)
    parser.add_argument('--flash-partition-idx', help="Flash partition index, it could be either 0 or 1", required=True)

    parser.add_argument('-v', '--verbose', action='count', default=0)
    

    args = parser.parse_args()

    logging_levels = {0: logging.ERROR,
                      1: logging.DEBUG,
                      2: logging.INFO,
                      3: logging.WARNING,
                      4: logging.ERROR,
                      5: logging.CRITICAL}
    
    logging.basicConfig(stream=sys.stdout, level=logging_levels[args.verbose])

    main(args.output_filepath, args.build_type, args.flash_partition_idx)
